<!DOCTYPE HTML PUBLIC "-//W3C//DTD HTML 4.01 Transitional//EN" "http://www.w3.org/TR/html4/loose.dtd">
<html>
<head>
<title>Events and Bindings</title>
<link rel='stylesheet' href='/media/css/pythonware.css' type='text/css'>

</head>
<body bgcolor='white' text='black'><a name='top'></a>
<table class='masthead' border='0' cellspacing='0' cellpadding='0' width='100%'><tr><td align='left'>
<a href='/index.htm'>pythonware.com</a> <!-- [debug: 0.11s 2013-02-11 05:48:57.956763] -->
</td><td align='right'>
<a href='/products/index.htm'>products</a> <span class='mark'>:::</span>
<a href='/library/index.htm'>library</a> <span class='mark'>:::</span>
<a href='/search.htm'>search</a> <span class='mark'>:::</span>
<a href='/daily/index.htm'><b>daily Python-URL!</b></a>
</td></tr></table>

<table border='0' cellspacing='0' cellpadding='0' width='100%'>
<tr><td width='120' valign='top'>
<div class='browser'>
<p><a href='../../../../..'>Library</a></p><p><a href='../../..'>An Introduction to Tkinter</a></p><p><b>Events and Bindings :::</b></p>
<div style='padding-top: 20px'><a href="http://www.djangoproject.com/"><img src="/media/img/djangosite80x15_grey.gif" border="0" alt="A Django site." title="A Django site." /></a></div>
</div>
</td>
<td width='10'>&nbsp;</td>
<td width='2' class='grid'></td>
<td width='10'>&nbsp;</td>
<td valign='top'>

<h1 class='title'>Events and Bindings</h1>
<div class='pad'>
<p><span align="left"><a href="x647-cursors.htm">Back</a>&#160;&#160;&#160;</span><span align="right"><a href="application-windows.htm">Next</a>&#160;&#160;&#160;</span></p><h1>&#160;<a id="AEN657" name="AEN657">Chapter 7. Events and
Bindings</a></h1>
<p>As was mentioned earlier, a Tkinter application spends most of
its time inside an event loop (entered via the <tt>mainloop</tt>
method). Events can come from various sources, including key
presses and mouse operations by the user, and redraw events from
the window manager (indirectly caused by the user, in many
cases).</p>
<p>Tkinter provides a powerful mechanism to let you deal with
events yourself. For each widget, you can <tt>bind</tt> Python
functions and methods to events.</p>
<pre>
    widget.bind(event, handler)
</pre>
<p>If an event matching the <i>event</i> description occurs in the
widget, the given <i>handler</i> is called with an object
describing the event.</p>
<p>Here's a simple example:</p>
<div>
<p><b>Example 7-1. Capturing clicks in a window</b></p>
<pre>
# File: bind1.py

from Tkinter import *

root = Tk()

def callback(event):
    print "clicked at", event.x, event.y 

frame = Frame(root, width=100, height=100)
frame.bind("&lt;Button-1&gt;", callback)
frame.pack()

root.mainloop()
</pre>
</div>
<p>In this example, we use the <tt>bind</tt> method of the frame
widget to bind a callback function to an event called <tt>
&lt;Button-1&gt;</tt>. Run this program and click in the window
that appears. Each time you click, a message like "<tt>clicked at
44 63</tt>" is printed to the console window.</p>
<div>
<h1>&#160;<a id="AEN676" name="AEN676">Events</a></h1>
<p>Events are given as strings, using a special event syntax:</p>
<pre>
    &lt;modifier-type-detail&gt;
</pre>
<p>The <i>type</i> field is the most important part of an event
specifier. It specifies the kind of event that we wish to bind, and
can be user actions like <tt>Button</tt>, and <tt>Key</tt>, or
window manager events like <tt>Enter</tt>, <tt>Configure</tt>, and
others. The modifier and detail fields are used to give additional
information, and can in many cases be left out. There are also
various ways to simplify the event string; for example, to match a
keyboard key, you can leave out the angle brackets and just use the
key as is. Unless it is a space or an angle bracket, of course.</p>
<p>Instead of spending a few pages on discussing all the syntactic
shortcuts, let's take a look on the most common event formats:</p>
<p><b>Table 7-1. Event Formats</b></p>
<table border="1">
<tr>
<th align="LEFT" valign="TOP" width="20%">Event</th>
<th align="LEFT" valign="TOP" width="80%">Description</th>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>
&lt;Button-1&gt;</tt></td>
<td align="LEFT" valign="TOP" width="80%">
<p>A mouse button is pressed over the widget. Button 1 is the
leftmost button, button 2 is the middle button (where available),
and button 3 the rightmost button. When you press down a mouse
button over a widget, Tkinter will automatically "grab" the mouse
pointer, and mouse events will then be sent to the current widget
as long as the mouse button is held down. The current position of
the mouse pointer (relative to the widget) is provided in the <tt>
x</tt> and <tt>y</tt> members of the event object passed to the
callback.</p>
<p>You can use <tt>ButtonPress</tt> instead of <tt>Button</tt>, or
even leave it out completely: <tt>&lt;Button-1&gt;</tt>, <tt>
&lt;ButtonPress-1&gt;</tt>, and <tt>&lt;1&gt;</tt> are all
synonyms. For clarity, I prefer the <tt>&lt;Button-1&gt;</tt>
syntax.</p>
</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>
&lt;B1-Motion&gt;</tt></td>
<td align="LEFT" valign="TOP" width="80%">The mouse is moved, with
mouse button 1 being held down (use B2 for the middle button, B3
for the right button). The current position of the mouse pointer is
provided in the <tt>x</tt> and <tt>y</tt> members of the event
object passed to the callback.</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>
&lt;ButtonRelease-1&gt;</tt></td>
<td align="LEFT" valign="TOP" width="80%">Button 1 was released.
The current position of the mouse pointer is provided in the <tt>
x</tt> and <tt>y</tt> members of the event object passed to the
callback.</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>
&lt;Double-Button-1&gt;</tt></td>
<td align="LEFT" valign="TOP" width="80%">Button 1 was double
clicked. You can use <tt>Double</tt> or <tt>Triple</tt> as
prefixes. Note that if you bind to both a single click
(&lt;<tt>Button-1&gt;</tt>) and a double click, both bindings will
be called.</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>
&lt;Enter&gt;</tt></td>
<td align="LEFT" valign="TOP" width="80%">The mouse pointer entered
the widget (this event doesn't mean that the user pressed the <b>
Enter</b> key!).</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>
&lt;Leave&gt;</tt></td>
<td align="LEFT" valign="TOP" width="80%">The mouse pointer left
the widget.</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>
&lt;Return&gt;</tt></td>
<td align="LEFT" valign="TOP" width="80%">The user pressed the
Enter key. You can bind to virtually all keys on the keyboard. For
an ordinary 102-key PC-style keyboard, the special keys are <b>
Cancel</b> (the Break key), <b>BackSpace</b>, <b>Tab</b>, <b>
Return</b>(the Enter key), <b>Shift_L</b> (any Shift key), <b>
Control_L</b> (any Control key), <b>Alt_L</b> (any Alt key), <b>
Pause</b>, <b>Caps_Lock</b>, <b>Escape</b>, <b>Prior</b> (Page Up),
<b>Next</b> (Page Down), <b>End</b>, <b>Home</b>, <b>Left</b>, <b>
Up</b>, <b>Right</b>, <b>Down</b>, <b>Print</b>, <b>Insert</b>, <b>
Delete</b>, <b>F1</b>, <b>F2</b>, <b>F3</b>, <b>F4</b>, <b>F5</b>,
<b>F6</b>, <b>F7</b>, <b>F8</b>, <b>F9</b>, <b>F10</b>, <b>F11</b>,
<b>F12</b>, <b>Num_Lock</b>, and <b>Scroll_Lock</b>.</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>&lt;Key&gt;</tt></td>
<td align="LEFT" valign="TOP" width="80%">The user pressed any key.
The key is provided in the <tt>char</tt> member of the event object
passed to the callback (this is an empty string for special
keys).</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>a</tt></td>
<td align="LEFT" valign="TOP" width="80%">The user typed an "a".
Most printable characters can be used as is. The exceptions are
space (<tt>&lt;space&gt;</tt>) and less than
(<tt>&lt;less&gt;</tt>). Note that <tt>1</tt> is a keyboard
binding, while <tt>&lt;1&gt;</tt> is a button binding.</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>
&lt;Shift-Up&gt;</tt></td>
<td align="LEFT" valign="TOP" width="80%">The user pressed the Up
arrow, while holding the Shift key pressed. You can use prefixes
like <b>Alt</b>, <b>Shift</b>, and <b>Control</b>.</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>
&lt;Configure&gt;</tt></td>
<td align="LEFT" valign="TOP" width="80%">The widget changed size
(or location, on some platforms). The new size is provided in the
<tt>width</tt> and <tt>height</tt> attributes of the event object
passed to the callback.</td>
</tr>
</table>
<h2>&#160;<a id="AEN806" name="AEN806">The Event
Object</a></h2>
<p>The event object is a standard Python object instance, with a
number of attributes describing the event.</p>
<div>
<p><b>Table 7-2. Event Attributes</b></p>
<table border="1">
<tr>
<th align="LEFT" valign="TOP" width="20%">Attribute</th>
<th align="LEFT" valign="TOP" width="80%">Description</th>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>widget</tt></td>
<td align="LEFT" valign="TOP" width="80%">The widget which
generated this event. This is a valid Tkinter widget instance, not
a name. This attribute is set for all events.</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>x, y</tt></td>
<td align="LEFT" valign="TOP" width="80%">The current mouse
position, in pixels.</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>x_root,
y_root</tt></td>
<td align="LEFT" valign="TOP" width="80%">The current mouse
position relative to the upper left corner of the screen, in
pixels.</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>char</tt></td>
<td align="LEFT" valign="TOP" width="80%">The character code
(keyboard events only), as a string.</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>keysym</tt></td>
<td align="LEFT" valign="TOP" width="80%">The key symbol (keyboard
events only).</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>keycode</tt></td>
<td align="LEFT" valign="TOP" width="80%">The key code (keyboard
events only)</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>num</tt></td>
<td align="LEFT" valign="TOP" width="80%">The button number (mouse
button events only)</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>width,
height</tt></td>
<td align="LEFT" valign="TOP" width="80%">The new size of the
widget, in pixels (Configure events only).</td>
</tr>
<tr>
<td align="LEFT" valign="TOP" width="20%"><tt>type</tt></td>
<td align="LEFT" valign="TOP" width="80%">The event type.</td>
</tr>
</table>
</div>
<p>For portability reasons, you should stick to <tt>char</tt>, <tt>
height</tt>, <tt>width</tt>, <tt>x</tt>, <tt>y</tt>, <tt>
x_root</tt>, <tt>y_root</tt>, and <tt>widget</tt> unless you know
exactly what you're doing...</p>
<h2>&#160;<a id="AEN864" name="AEN864">Instance and Class
Bindings</a></h2>
<p>The <tt>bind</tt> method we used in the above example creates an
instance binding. This means that the binding applies to a single
widget only; if you create new frames, they will not inherit the
bindings.</p>
<p>But Tkinter also allows you to create bindings on the class and
application level; in fact, you can create bindings on four
different levels:</p>
<ul>
<li>
<p>the widget instance, using <tt>bind</tt>.</p>
</li>
<li>
<p>the widget's toplevel window (Toplevel or <tt>root</tt>), also
using <tt>bind</tt>.</p>
</li>
<li>
<p>the widget class, using <tt>bind_class</tt> (this is used by
Tkinter to provide standard bindings).</p>
</li>
<li>
<p>the whole application, using <tt>bind_all</tt>.</p>
</li>
</ul>
<p>For example, you can use <tt>bind_all</tt> to create a binding
for the F1 key, so you can provide help everywhere in the
application. But what happens if you create multiple bindings for
the same key, or provide overlapping bindings?</p>
<p>First, on each of these four levels, Tkinter chooses the
"closest match" of the available bindings. For example, if you
create instance bindings for the <tt>&lt;Key&gt;</tt> and <tt>
&lt;Return&gt;</tt> events, only the second binding will be called
if you press the <b>Enter</b> key.</p>
<p>However, if you add a <tt>&lt;Return&gt;</tt> binding to the
toplevel widget, <i>both</i> bindings will be called. Tkinter first
calls the best binding on the instance level, then the best binding
on the toplevel window level, then the best binding on the class
level (which is often a standard binding), and finally the best
available binding on the application level. So in an extreme case,
a single event may call four event handlers.</p>
<p>A common cause of confusion is when you try to use bindings to
override the default behavior of a standard widget. For example,
assume you wish to disable the Enter key in the text widget, so
that the users cannot insert newlines into the text. Maybe the
following will do the trick?</p>
<pre>
    def ignore(event):
        pass
    text.bind("&lt;Return&gt;", ignore)
</pre>
<p>or, if you prefer one-liners:</p>
<pre>
    text.bind("&lt;Return&gt;", lambda e: None)
</pre>
<p>(the <tt>lambda</tt> function used here takes one argument, and
returns <tt>None</tt>)</p>
<p>Unfortunately, the newline is still inserted, since the above
binding applies to the instance level only, and the standard
behavior is provided by a class level bindings.</p>
<p>You could use the <tt>bind_class</tt> method to modify the
bindings on the class level, but that would change the behavior of
<i>all</i> text widgets in the application. An easier solution is
to prevent Tkinter from propagating the event to other handlers;
just return the string "<tt>break</tt>" from your event
handler:</p>
<pre>
    def ignore(event):
        return "break"
    text.bind("&lt;Return&gt;", ignore)
</pre>
<p>or</p>
<pre>
    text.bind("&lt;Return&gt;", lambda e: "break")
</pre>
<p>By the way, if you really want to change the behavior of all
text widgets in your application, here's how to use the <tt>
bind_class</tt> method:</p>
<pre>
    top.bind_class("Text", "&lt;Return&gt;", lambda e: None)
</pre>
<p>But there are a lot of reasons why you shouldn't do this. For
example, it messes things up completely the day you wish to extend
your application with some cool little UI component you downloaded
from the net. Better use your own <tt>Text</tt> widget
specialization, and keep Tkinter's default bindings intact:</p>
<pre>
    class MyText(Text):
        def __init__(self, master, **kw):
            apply(Text.__init__, (self, master), kw)
            self.bind("&lt;Return&gt;", lambda e: "break")
</pre>
<h2>&#160;<a id="AEN915" name="AEN915">Protocols</a></h2>
<p>In addition to event bindings, Tkinter also supports a mechanism
called <i>protocol handlers.</i> Here, the term protocol refers to
the interaction between the application and the window manager. The
most commonly used protocol is called <tt>WM_DELETE_WINDOW</tt>,
and is used to define what happens when the user explicitly closes
a window using the window manager.</p>
<p>You can use the <tt>protocol</tt> method to install a handler
for this protocol (the widget must be a root or <tt>Toplevel</tt>
widget):</p>
<pre>
    widget.protocol("WM_DELETE_WINDOW", handler)
</pre>
<p>Once you have installed your own handler, Tkinter will no longer
automatically close the window. Instead, you could for example
display a message box asking the user if the current data should be
saved, or in some cases, simply ignore the request. To close the
window from this handler, simply call the <tt>destroy</tt> method
of the window:</p>
<div>
<p><b>Example 7-2. Capturing destroy events</b></p>
<pre>
# File: protocol1.py

from Tkinter import *
import tkMessageBox

def callback():
    if tkMessageBox.askokcancel("Quit", "Do you really wish to quit?"):
        root.destroy()

root = Tk()
root.protocol("WM_DELETE_WINDOW", callback)

root.mainloop()
</pre>
</div>
<p>Note that even you don't register an handler for <tt>
WM_DELETE_WINDOW</tt> on a toplevel window, the window itself will
be destroyed as usual (in a controlled fashion, unlike X). However,
as of Python 1.5.2, Tkinter will not destroy the corresponding
widget instance hierarchy, so it is a good idea to always register
a handler yourself:</p>
<pre>
    top = Toplevel(...)

    # make sure widget instances are deleted
    top.protocol("WM_DELETE_WINDOW", top.destroy)
</pre>
<p>Future versions of Tkinter will most likely do this by
default.</p>
<h2>&#160;<a id="AEN933" name="AEN933">Other
Protocols</a></h2>
<p>Window manager protocols were originally part of the X window
system (they are defined in a document titled <i>Inter-Client
Communication Conventions Manual</i>, or ICCCM). On that platform,
you can install handlers for other protocols as well, like <tt>
WM_TAKE_FOCUS</tt> and <tt>WM_SAVE_YOURSELF</tt>. See the ICCCM
documentation for details.</p>
</div>
<p><span align="left"><a href="x647-cursors.htm">Back</a>&#160;&#160;&#160;</span><span align="right"><a href="application-windows.htm">Next</a>&#160;&#160;&#160;</span></p>
</div>

</td></tr>
</table>

<script src="http://www.google-analytics.com/urchin.js" type="text/javascript"></script>
<script type="text/javascript">
_uacct = "UA-578832-2";
urchinTracker();
</script>

</body>
</html>
